/*
 * This file is part of the Cordless Power Tool Vacuum Start distribution
 * (https://github.com/abudden/cordlessvacuumstart).
 * Copyright (c) 2022 A. S. Budden
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

// Transmitter code to control remote-controlled switches

#include "Global.h"
#include "Clock.h"
#include "Pins.h"
#include "DefinedPins.h"

#include "Transmitter.h"

#include "_SocketInfo.h" // Auto-generated by python build script

#define TTIMER TIM2
#define COMPARE TTIMER->CCR2

// Most of the defined values (SOCKET_*) are populated automatically by compile.py

#ifdef PERIOD_DEBUGGING
#warning Compiling with non-fixed transmitter period
uint16_t period_us = SOCKET_BIT_PERIOD;
#else
static const uint16_t period_us = SOCKET_BIT_PERIOD;
#endif
static const uint32_t base_pattern = SOCKET_BASE_PATTERN;
static const uint32_t off_mask = SOCKET_OFF_PATTERN;
static const uint32_t on_mask = SOCKET_ON_PATTERN;
static const uint32_t unit_mask = SOCKET_UNIT_CODE;
static const uint16_t pattern_length = SOCKET_PATTERN_LENGTH;

#ifdef SOCKET_ON_TIME_OVERRIDE
static const uint16_t bit1_on_time = SOCKET_BIT1_ON_TIME;
static const uint16_t bit0_on_time = SOCKET_BIT0_ON_TIME;
#else
static uint16_t bit1_on_time = 0;
static uint16_t bit0_on_time = 0;
#endif
static volatile uint32_t next_transmit_word = UINT32_MAX;
static uint16_t transmit_value = 0; 
static volatile int bit_number = 0;

static enum {
	TRANSMIT_Disabled,
	TRANSMIT_TurnOff,
	TRANSMIT_TurnOn,
	TRANSMIT_Value
} transmit_state;

extern "C" void TIM2_IRQHandler()
{
	// Interrupt handler for bit transmission complete: send the next bit
	static int pause_counter = 0;
	static uint32_t transmit_word = 0;

	TTIMER->SR &= (uint16_t) (~TIM_SR_UIF);
	if (pause_counter > 0) {
		// Pause counter is used to insert a gap between each packet transmission.
		// By default the gap is the same as the transmission duration.
		pause_counter -= 1;
		COMPARE = 0;
		transmit_word = next_transmit_word;
		return;
	}
	// Extract the bit from the configured transmit word
	uint32_t this_bit = ((transmit_word >> (pattern_length-(1+bit_number))) & 0x1U);

	// Set the on time according to whether it's a 0 or a 1
	if (this_bit == 0) {
		COMPARE = bit0_on_time;
	}
	else {
		COMPARE = bit1_on_time;
	}

	bit_number += 1;
	if (bit_number >= pattern_length) {
		pause_counter = pattern_length;
		bit_number = 0;
	}
}

void InitTransmitter()
{
	// Configure the LED for use as a "transmitting" indicator
	SetPinAsGPO_PP(LED_PIN);
	SetPinState(LED_PIN, false);

	// Initial configuration settings - may be changed later
	TTIMER->CR1 = 0;
	TTIMER->CR2 = 0;
	TTIMER->SMCR = 0;

	// Enable interrupt on update (timer wrap-around) events
	TTIMER->DIER = TIM_DIER_UIE;
	TTIMER->EGR = 0;

	// Put the capture compare 2 output into an appropriate mode
	// so that the pin is high before compare match and low afterwards
	TTIMER->CCMR1 = (uint32_t) 0U
		| (0x6U << TIM_CCMR1_OC2M_Pos);

	// Enable capture compare 2.
	TTIMER->CCER = TIM_CCER_CC2E;

	// Clock is running at 48 MHz but we want timer to operate at 1Â MHz
	// for microsecond resolution
	TTIMER->PSC = 48U;

#ifndef SOCKET_ON_TIME_OVERRIDE
	// Most units transmit 0 as 25% duty cycle and
	// 1 as 75% duty cycle.
	bit1_on_time = (3 * period_us) >> 2;
	bit0_on_time = (1 * period_us) >> 2;
#endif

	// Set the timer wrap time as the bit period in microseconds
	TTIMER->ARR = (uint16_t) period_us;
	// Start with compare = 0 so nothing comes out (counter value is
	// always >= COMPARE, so output is low).
	COMPARE = 0U; // using T2CH2

	// Configure pin for CC2 output
	SetPinAsAFO_PP(TRANSMIT_PIN, 1);

	// Turn on the interrupt so we know when the timer wraps and can
	// load the next bit
	NVIC_EnableIRQ(TIM2_IRQn);
	NVIC_SetPriority(TIM2_IRQn, 3);
}

void UpdateTransmitter()
{
	uint32_t preparation;

	if (transmit_state == TRANSMIT_Disabled) {
		// Reset the counter in case it's still running
		TTIMER->SR &= (uint16_t) (~TIM_SR_UIF);
		TTIMER->CR1 &= (uint16_t) (~(TIM_CR1_CEN));
		// Then set the count and COMPARE to 0
		TTIMER->CNT = 0;
		COMPARE = 0;
		// Clear the next transmit word to an invalid state
		next_transmit_word = UINT32_MAX;
		SetPinState(LED_PIN, false);
	}
	else {
		SetPinState(LED_PIN, true);

		// Start with the base pattern and then use bitwise-or operations
		// to merge the unit mask and the command (on/off) mask
		preparation = base_pattern;
		preparation |= unit_mask;
		if (transmit_state == TRANSMIT_TurnOn) {
			preparation |= on_mask;
		}
		else if (transmit_state == TRANSMIT_TurnOff) {
			preparation |= off_mask;
		}
		else if (transmit_state == TRANSMIT_Value) {
			// Transmits a 16 bit value as a nBits bit word
			preparation = transmit_value;
		}
		else {
			// Should never get here
		}
		// Data all prepared, so transfer into the variable that the interrupt
		// will use
		next_transmit_word = preparation;

		// If the timer's not running, start it
		if ((TTIMER->CR1 & TIM_CR1_CEN) == 0) {
			// Start off with COMPARE = 0
			// the ISR will sort out the actual bit
			// transmission.
			bit_number = 0;
			COMPARE = 0;
			TTIMER->CR1 |= TIM_CR1_CEN;
		}
	}
}

void StartTransmitting(bool on)
{
	if (on) {
		transmit_state = TRANSMIT_TurnOn;
	}
	else {
		transmit_state = TRANSMIT_TurnOff;
	}
}

void StopTransmitting()
{
	transmit_state = TRANSMIT_Disabled;
}

void NextTransmitterState() {
	// For testing
	switch (transmit_state) {
		case TRANSMIT_Disabled:
			transmit_state = TRANSMIT_TurnOn;
			break;
		case TRANSMIT_TurnOn:
			transmit_state = TRANSMIT_TurnOff;
			break;
		case TRANSMIT_TurnOff:
		default:
			transmit_state = TRANSMIT_Disabled;
	}
}

uint8_t GetTransmitterState()
{
	return (uint8_t) transmit_state;
}

uint8_t IsTransmitting()
{
	if (transmit_state == TRANSMIT_Disabled) {
		return false;
	}
	return true;
}

uint32_t GetTransmitWord()
{
	return next_transmit_word;
}

void StartTransmittingValue(uint16_t value)
{
	transmit_state = TRANSMIT_Value;
	transmit_value = value;
}
